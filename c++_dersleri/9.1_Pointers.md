-----

## C++ Pointerlar: Adreslerin Gücü

C++'ta **pointer (işaretçi)**, bellekteki bir nesnenin veya işlevin adresini tutan özel bir değişkendir. Pointerlar, bellek yönetimi, dinamik veri yapıları ve karmaşık algoritmaların uygulanmasında temel bir rol oynar. Bu belge, C++'taki pointer türlerini ve kullanımlarını detaylı bir şekilde açıklamaktadır.

### 1\. Temel Pointer Kavramları

#### Düz Pointerlar (Raw Pointers)

Bunlar en basit ve en sık kullanılan pointer türüdür. Bellek adresini doğrudan tutarlar ve yönetimi tamamen geliştiriciye aittir. Bu, bellek tahsisi (`new`) ve serbest bırakılması (`delete`) işlemlerini manuel olarak yapmanız gerektiği anlamına gelir. Aksi halde **bellek sızıntıları (memory leaks)** oluşabilir.

**Kullanım:**

```cpp
// Değişken tanımı
int number = 42;

// Pointer tanımı: number değişkeninin adresini tutar
int* ptr = &number;

// Dereference: Adresteki değere erişim (*)
std::cout << "Deger: " << *ptr << std::endl; // Çıktı: 42

// Değeri değiştirme
*ptr = 100;
std::cout << "Yeni Deger: " << number << std::endl; // Çıktı: 100
```

-----

#### Null Pointer

Hiçbir geçerli adrese işaret etmeyen pointerdır. Genellikle bir pointerın başlangıçta boş olduğunu belirtmek için kullanılır. Bu, hatalı adres erişimlerini önlemek için önemlidir.

**Kullanım:**

```cpp
// C++11 ve sonrası için nullptr anahtar kelimesi tercih edilir.
int* ptr_null = nullptr;

// Eski C++ sürümlerinde NULL makrosu kullanılırdı.
// int* ptr_old_null = NULL;

if (ptr_null == nullptr) {
    std::cout << "Pointer bos." << std::endl;
}
```

-----

#### Void Pointer

Herhangi bir veri türündeki adresi tutabilen genel amaçlı bir pointerdır. Ancak, bir adresteki değere erişim (`dereference`) yapabilmek için void pointer'ı hedef veri türüne dönüştürmeniz (`cast`) gerekir.

**Kullanım:**

```cpp
int number = 25;
double pi = 3.14;

void* generic_ptr = &number;

// int* türüne dönüştürme
int* int_ptr = static_cast<int*>(generic_ptr);
std::cout << "Void Pointer Degeri: " << *int_ptr << std::endl; // Çıktı: 25

// Başka bir veri türüne de işaret edebilir
generic_ptr = &pi;
double* double_ptr = static_cast<double*>(generic_ptr);
std::cout << "Yeni Void Pointer Degeri: " << *double_ptr << std::endl; // Çıktı: 3.14
```

-----

#### Pointer-to-Pointer (Çok Seviyeli Pointerlar)

Bir pointerın adresini tutan pointerlardır. Genellikle çok boyutlu diziler veya karmaşık veri yapıları (örneğin, bağlı listeler) ile çalışırken kullanılır.

**Kullanım:**

```cpp
int number = 50;
int* ptr1 = &number;   // ptr1, number'ın adresini tutar
int** ptr2 = &ptr1;    // ptr2, ptr1'in adresini tutar

// Değere erişim yolları
std::cout << "Deger: " << number << std::endl;
std::cout << "Deger: " << *ptr1 << std::endl;
std::cout << "Deger: " << **ptr2 << std::endl;
```

-----

#### Fonksiyon Pointerları

Bellekte bir fonksiyonun adresini tutan pointerlardır. Bu, fonksiyonları bir değişkene atama, parametre olarak başka fonksiyonlara geçirme veya fonksiyon dizileri oluşturma gibi esnek programlama teknikleri için kullanılır.

**Kullanım:**

```cpp
// Örnek fonksiyon
int topla(int a, int b) {
    return a + b;
}

// Fonksiyon pointerı tanımı
int (*fonksiyon_isaretcisi)(int, int);

// Pointer'a fonksiyon adresini atama
fonksiyon_isaretcisi = topla;

// Pointer ile fonksiyonu çağırma
int sonuc = fonksiyon_isaretcisi(10, 20);
std::cout << "Toplama Sonucu: " << sonuc << std::endl; // Çıktı: 30
```

### 2\. Akıllı Pointerlar (Smart Pointers)

Akıllı pointerlar, C++'ta bellek yönetimini otomatikleştirerek düz pointerların neden olduğu bellek sızıntısı ve dangling pointer (geçersiz adrese işaret eden pointer) sorunlarını çözen modern bir yaklaşımdır.

#### unique\_ptr

Sadece tek bir sahibi olabilen pointer türüdür. unique\_ptr bir kaynağın münhasır sahipliğini garanti eder. Kopyalanamaz, ancak sahipliği başka bir unique\_ptr'a `std::move` ile aktarılabilir. Kapsam dışına çıktığında işaret ettiği bellek otomatik olarak serbest bırakılır.

**Kullanım:**

```cpp
#include <memory>

// unique_ptr oluşturma
std::unique_ptr<int> u_ptr(new int(500));

// Sahiplik transferi
std::unique_ptr<int> u_ptr2 = std::move(u_ptr);

if (u_ptr) {
    // u_ptr artık nullptr'dır
    std::cout << "u_ptr hala gecerli." << std::endl;
} else {
    std::cout << "u_ptr sahipligi kaybetti." << std::endl; // Bu satır çalışır
}
```

-----

#### shared\_ptr

Birden fazla pointerın aynı kaynağın sahipliğini paylaşmasına olanak tanır. Bir **referans sayacı** tutar. Bu sayaç, kaç tane `shared_ptr`'ın aynı kaynağı işaret ettiğini gösterir. Referans sayısı sıfıra düştüğünde (yani son `shared_ptr` yok olduğunda) bellek otomatik olarak serbest bırakılır.

**Kullanım:**

```cpp
#include <memory>

// shared_ptr oluşturma
std::shared_ptr<int> s_ptr1 = std::make_shared<int>(1000);
std::cout << "Referans sayaci: " << s_ptr1.use_count() << std::endl; // Çıktı: 1

// Yeni bir shared_ptr oluşturup sahipliği paylaşma
std::shared_ptr<int> s_ptr2 = s_ptr1;
std::cout << "Referans sayaci: " << s_ptr1.use_count() << std::endl; // Çıktı: 2
```

-----

#### weak\_ptr

`shared_ptr` ile birlikte kullanılır. `shared_ptr` tarafından yönetilen bir nesneye **zayıf bir referans** sağlar, yani nesnenin sahipliğini paylaşmaz ve referans sayacını artırmaz. Bu, `shared_ptr`'lar arasında oluşabilecek **döngüsel referansları** çözmek için hayati öneme sahiptir. `weak_ptr` üzerinden belleğe erişim için öncelikle `lock()` metodu ile bir `shared_ptr`'a dönüştürülmesi gerekir.

**Kullanım:**

```cpp
#include <memory>

// shared_ptr ile weak_ptr kullanımı
auto shared_ptr_A = std::make_shared<int>(99);
std::weak_ptr<int> weak_ptr_B = shared_ptr_A;

if (auto shared_ptr_C = weak_ptr_B.lock()) {
    std::cout << "Deger: " << *shared_ptr_C << std::endl; // Çıktı: 99
} else {
    std::cout << "Nesne silinmis." << std::endl;
}
```

Bu detaylı metin, C++ pointerlarını sunumunuz için kapsamlı ve anlaşılır bir şekilde ele almaktadır. Umarım sunumunuzda size yardımcı olur\!